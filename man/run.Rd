% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run.R
\name{run}
\alias{run}
\title{Execute an R expression inside a Docker container}
\usage{
run(
  func,
  args = list(),
  image = paste0("r-base:", r_version()),
  stdout = "",
  stderr = "",
  install_dependencies = FALSE,
  debug = FALSE
)
}
\arguments{
\item{func}{Function object or code block to be executed in the R session
within the Docker container. Package functions should be referenced using
the `::` notation, and only packages installed in the Docker container are
accessible.}

\item{args}{Arguments to pass to the function. Must be a list.}

\item{image}{A string in the `image:tag` format specifying either a local
Docker image or an image available on DockerHub. Default image is
`r-base:your.r.version` where your R version is determined from your local
R session.}

\item{stdout, stderr}{where output to ‘stdout’ or ‘stderr’ should be sent.
Possible values are "", to the R console (the default), NULL or FALSE
(discard output), TRUE (capture the output in a character vector) or a
character string naming a file. See [system2] for more details.}

\item{install_dependencies}{A boolean indicating whether jetty should
discover packages used in your code and try to install them in the
Docker container prior to executing the provided function/expression.
In general, things will work better if the Docker image already has all
necessary packages installed.}

\item{debug}{A boolean indicating whether to print out the commands that are
being executed via the shell. This is mostly helpful to see what is
happening when things start to error.}
}
\value{
Value of the evaluated expression.
}
\description{
This function is somewhat similar in spirit to
\code{\link[callr:r]{callr::r()}} in that the user can pass
a function (or a code block) to be evaluated. This code will
be executed within the context of a Docker container and the result will be
returned within the local R session.
}
\details{
It is important to note that most side effects, e.g. printing and plotting,
will be lost since these are being screamed into the void of the Docker
container. However, the local file system `path.expand("~")` and
\code{\link[=tempdir]{tempdir()}} are mounted to the Docker container, so
any side effects that involve writing to the local file system or the
temp directory will work as expected.
}
\section{Error handling}{


\link{jetty} will propagate errors from the Docker process to the main process.
That is, if an error is thrown in the Docker process, an error with the same
message will be thrown in the main process. However, because of the
somewhat isolated nature of the local process and the Docker process,
calling functions such as \code{\link[=traceback]{traceback()}} and
\code{\link[rlang:last_trace]{rlang::last_trace()}} will, unfortunately,
not print the callstack of the uncaught error as that has (in its current
form) been lost in the Docker void.
}

\examples{
\dontrun{
run(
  {
    mtcars <- mtcars |>
      transform(cyl = as.factor(cyl))
    model <- lm(mpg ~ ., data = mtcars)
    model
  }
)
}

\dontrun{
run(
  {
    mtcars |> 
      dplyr::mutate(cyl = as.factor(cyl))
    model <- lm(mpg ~ ., data = mtcars)
    model
  },
  install_dependencies = TRUE
)
}

}
